<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginaPage extends BaseaPage
{
  const NEXT_PERMID = -1;
  public $culture;
  
  // Keep all cached information here for easy reference and inclusion 
  // in the reset code in hydrate()
  public $privilegesCache = null;
  protected $slotCache = false;
  protected $childrenCache = null;
  protected $childrenCacheLivingOnly = null;
  protected $childrenCacheSlot = null;
  protected $ancestorsCache = false;
  protected $parentCache = false;

  public function hydrate(array $data, $overwriteLocalChanges = true)
  {
    // Purge all caches when Doctrine refreshes the object
    $this->slotCache = false;
    $this->privilegesCache = array();
    $this->childrenCache = null;
    $this->childrenCacheLivingOnly = null;
    $this->childrenCacheSlot = null;
    $this->ancestorsCache = false;
    $this->parentCache = false;
    return parent::hydrate($data, $overwriteLocalChanges);
  }

  // Not a typo. Doctrine calls construct() for you as an alternative
  // to __construct(), which it won't let you override.
  public function construct()
  {
    $this->culture = aTools::getUserCulture();
    $this->privilegesCache = array();
  }
  protected function log($message)
  {
    sfContext::getInstance()->getLogger()->info("PAGE: $message");
  }

  public function userHasPrivilege($privilege, $user = false)
  {
    return aPageTable::checkPrivilege($privilege, $this, $user);
  }

  // The new API:
  //
  // getArea(name)   returns slots for an area name (not an aArea object, which is low level implementation stuff)
  // newAreaVersion(name, action, params)    makes a change to an area, see function for details
  // getAllSlots()    returns all current slots on page, see function for details
  
  // Simple public access to the current slots,
  // organized by culture, area name and permid, ordered by rank in
  // the area (assuming of course that you fetched this page
  // properly with retrieveBySlug or another public function in
  // aPageTable). Note that in most cases only slots for one culture
  // are returned, you will never see more than one culture unless
  // you expressly requested that in your query call. The result
  // looks like this:
  
  // $allSlots['en']['body'][1] = aSlot subclass object
  
  // Note that some permids may not be present in a particular version, 
  // you should be using a foreach loop, not assuming they start from 1
  
  public function getAllSlots()
  {
    return $this->slotCache;
  }
    
  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place.
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.
  
  public function hasSlot($name, $permid = 1)
  {
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture][$name][$permid]))
    {
      return true;
    }
    return false;
  }
  public function getSlot($name, $permid = 1)
  {
    if ($this->hasSlot($name, $permid))
    {
      return $this->slotCache[$this->culture][$name][$permid];
    }
    return false;
  }
  
  // Slightly misnamed, this method should really be called getAreaSlots but is
  // named this way for historical reasons
  
  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place.
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.
  
  // $new can be a slot class name, an already-created slot object, or false.
  // If it is false no new slot is added to the list to be returned.
  // If it is a class name the slot is constructed for you. 
  //
  // If $newFirst is true the new slot will be at the top of the area,
  // otherwise the bottom.
  public function getArea($name, $new = false, $newFirst = false)
  {
    $this->populateSlotCache();
    $results = array();
    if ($new)
    {
      $permidAndRank = $this->getNextPermidAndRank($name, $newFirst);
      if (!($new instanceof aSlot))
      {
        // It's a type name, make one
        $new = $this->createSlot($new);
      }
      else
      {
        // We passed one in
      }
    }
    if ($new && $newFirst)
    {
      $results[$permidAndRank['permid']] = $new;
    }
    if (isset($this->slotCache[$this->culture][$name]))
    {
      foreach ($this->slotCache[$this->culture][$name] as $permid => $slot)
      {
        $results[$permid] = $slot;
      }
    }
    if ($new && (!$newFirst))
    {
      $results[$permidAndRank['permid']] = $new;
    }
    return $results;
  }

  protected function populateSlotCache()
  {
    if ($this->slotCache === false)
    {
      $this->slotCache = array();
      // We have $this->Areas courtesy of whatever query
      // fetched the page in the first place
      foreach ($this->Areas as $area)
      {
        $areaVersion = $area->AreaVersions[0];
        foreach ($areaVersion->AreaVersionSlots as $areaVersionSlot)
        {
          $slot = $areaVersionSlot->Slot;
          // Tolerate missing slots, can't crash just because the db surprises you
          if ($slot)
          {
            $this->slotCache[$this->culture][$area->name][$areaVersionSlot->permid] = $slot;
          }
          // foreach ($slot->MediaItems as $mediaItem)
          // {
          //   echo($mediaItem->id . ',');
          // }
        }
      }
    }
  }
  
  /* Returns entity-escaped plaintext with newlines */
  public function getAreaText($areaname, $word_limit = false)
  {
    $slots = $this->getArea($areaname);
    $text = '';
    foreach ($slots as $slot)
    {
      if (strlen($text))
      {
        $text .= "\n\n";
      }
      $text .= $slot->getText();
    }
		if ($word_limit) {
			return aString::limitWords($text, $word_limit, array('append_ellipsis' => true));
		}
		else
		{
	    return $text;			
		}
  }

  public function getAreaBasicHtml($areaname, $word_limit = false)
  {
    $slots = $this->getArea($areaname);
    $text = '';
    foreach ($slots as $slot)
    {
      if (strlen($text))
      {
        // div might not be permitted in a lot of 'basic html'
        // contexts, but we do need some vertical break between
        // two slots to reasonably reproduce what
        // Apostrophe does with them
        $text .= '<br />';
      }
      $text .= $slot->getBasicHtml();
    }
		if ($word_limit) {
	    return aHtml::limitWords($text, $word_limit, array('append_ellipsis' => true));
		}
		else
		{
	    return $text;			
		}
  }

	public function getRichTextForArea($areaname, $word_limit = false)
	{
		$this->getAreaBasicHtml($areaname, $word_limit);
	}

  public function getNextPermidAndRank($name, $first = false)
  {
    $query = Doctrine_Query::create()->
        select('max(s.permid) as m, ' 
          . ($first ? 'min' : 'max') . '(s.rank) as r')->
        from('aArea a')->
        leftJoin('a.AreaVersions v')->
        leftJoin('v.AreaVersionSlots s')->
        where('a.name = ? AND a.page_id = ?', array($name, $this->id));
    $result = $query->execute();
         
    if (isset($result[0]['m']))
    {
      $permid = $result[0]['m'] + 1;
    }
    else
    {
      $permid = 1;
    }
    // Negative ranks = perfectly fine and useful for
    // implementing "new slots on top"
    if (isset($result[0]['r']))
    {
      if ($first)
      {
        $rank = $result[0]['r'] - 1;
      }
      else
      {
        $rank = $result[0]['r'] + 1;
      }
    }
    else
    {
      $rank = 1;
    }
    return array(
      'permid' => $permid, 
      'rank' => $rank);
  }

  public function createSlot($type)
  {
    $class = $type . "Slot";
    $slot = new $class;
    $slot->type = $type;
    return $slot;
  }

  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place. (You can also use aPageTable::retrieveBySlugWithTitles()
  // to avoid loading other slots on the page, but only if you don't turn around and try
  // to use those other slots.)
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.

  public function getTitle()
  {
    $titleSlot = $this->getSlot('title');
    if ($titleSlot)
    {
      $result = $titleSlot->value;
    }
    else
    {
      $result = '';
    }
    $title = trim($result);
    if (!strlen($result))
    {
      // Don't break the UI, return something reasonable
      $slug = $this->slug;
      $title = substr(strrchr($slug, "/"), 1);
      if (!strlen($title))
      {
        if ($this->isNew())
        {
          $title = '';
        }
        else
        {
          $title = "Home";
        }
      }
    }
    return $title;
  }
  
  public function getMetaDescription()
  {
  	$metaDescriptionSlot = $this->getSlot('metaDescription');
  	
  	$result = '';
  	if ($metaDescriptionSlot)
  	{
  		$result = $metaDescriptionSlot->value;
  	}
  	return trim($result);
  }
  
  
  
  // Changed in 1.5: returns a flat array, not an associative array indexed by version.
  // The latter was not very useful and made it difficult to pass through JSON
  // in a useful form
  
  public function getAreaVersions($name, $selectOptions = true, $limit = 10)
  {
    $q = Doctrine_Query::create()->
      from("aAreaVersion av")->
      leftJoin("av.Area a")->
      leftJoin("av.Author au")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      orderBy("av.version desc");
    if(!is_null($limit))
      $q->limit($limit);
    $areaVersions = $q->execute();
    $versions = array();  
    foreach ($areaVersions as $areaVersion)
    {
      if ($selectOptions)
      {
        $versions[$areaVersion->version] = 
          $areaVersion->created_at . " " . ($areaVersion->Author ? 
              $areaVersion->Author->username : "NONE") . " " . $areaVersion->diff;
      }
      else
      {
        $versions[] =
          array("created_at" => $areaVersion->created_at, "author" => $areaVersion->Author ? $areaVersion->Author->username : "NONE", "diff" => $areaVersion->diff,
          "version" => $areaVersion['version']);
      }
    }
    return $versions;   
  }

  public function getAreaCurrentVersion($name)
  {
    $area = Doctrine_Query::create()->
      from("aArea a")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      fetchOne();
    if ($area)
    {
      return $area->latest_version;
    }
    return 0;
  }

  // This is not the most efficient way to learn about the child pages of the current page.
  // See getChildrenInfo. This method is now primarily for backwards compatibility and relatively rare cases where 
  // you need a slot other than the title.
    
  // Returns an array even when there are zero children.
  // Who in the world wants to special case that as if it
  // were the end of the world?
  public function getChildren($livingOnly = true, $withSlot = 'title')
  {
    if ($this->childrenCache !== null)
    {
      if (($livingOnly === $this->childrenCacheLivingOnly) && ($this->childrenCacheSlot === $withSlot))
      {
        return $this->childrenCache;
      }
    }
    // TODO: consider whether it's possible to get the base query to
    // exclude archived children. That would result in multiple
    // calls to where(), but perhaps Doctrine can combine them for us.
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOn($withSlot);      
    }
    $children = $this->getNode()->getChildren();
    
    if ($children === false)
    {
      $children = array();
    }
    
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOff();
    }
    
    // Don't let Doctrine's clever reuse of objects prevent us from seeing
    // the results if we fetch a different slot this time... unless the child
    // is also the current page. In that case we assume that we have superior
    // data in the cache already (inclusive of all slots). Discarding that
    // was leading to disappearing data on emap
      
    $current = aTools::getCurrentPage();
    foreach ($children as $child)
    {
      if ($current && ($current->id === $child->id))
      {
        continue;
      }
      $child->clearSlotCache();
    }
    if ($children !== false)
    {
      $living = array();
      $dead = array();
      foreach ($children as $child)
      {
        if ($child->admin)
        {
          // Never show admin pages in navigation
          continue;
        }
        if ($child->archived)
        {
          $dead[] = $child;
        }
        else
        {
          $living[] = $child;
        }
      }
      if ($livingOnly)
      {
        $children = $living;
      }
      else
      {
        $children = array_merge($living, $dead);
      }
    }
    else
    {
      $children = array();
    }
    $this->childrenCache = $children;
    $this->childrenCacheLivingOnly = $livingOnly;
    $this->childrenCacheSlot = $withSlot;
    return $children;
  }

  // Optimized methods returning information about related pages.
  
  // All of these methods return an array of associative arrays, as follows:
  
  // array(
  //   array('id' => page1id, 'title' => page1title, 'slug' => page1slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level),
  //   array('id' => page2id, 'title' => page2title, 'slug' => page2slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level) ...
  // )
  
  // The getTreeInfo and getAccordionInfo methods return nested arrays. If a page has children that
  // are suitable to return, then the associative array for that page will have a 'children' key, and
  // the value will be an array of child pages, which may have children of their own. If a page has
  // no children there will not be a 'children' key (you may test isset($info['children'])).
  
  // To generate a URL for a page use: aTools::urlForPage($info['slug'])
    
  public function getAncestorsInfo($includeSelf = false, $livingOnly = false)
  {
    return aPageTable::getAncestorsInfo(array('info' => $this->getInfo(), 'includeSelf' => $includeSelf, 'livingOnly' => $livingOnly));
  }

  // Careful, the cache must hold the entire path including the item itself, we lop off the last element
	// before returning in those cases where it is not wanted. Note that $livingOnly does NOT change the 'level'
	// field for each returned ancestor

  protected $ancestorsInfo = array();

  public function getParentInfo()
  {
    return aPageTable::getParentInfo(array('info' => $this->getInfo()));
  }

  protected $peerInfo;
  
  // The $livingOnly flag is present for bc only and is ignored, we get what the current user can see
  
  public function getPeerInfo($livingOnly = true)
  {
    return aPageTable::getPeerInfo(array('info' => $this->getInfo(), 'livingOnly' => $livingOnly));
  }

  // Sometimes it is useful to have an info structure describing a page object
  // (the aNavigation classes exploit this, so does the search index, which needs
  // to be able to determine privileges for a page with a minimum of overhead)
  
  public function getInfo()
  {
    return array('id' => $this->id, 'title' => $this->getTitle(), 'slug' => $this->slug, 'view_is_secure' => $this->view_is_secure, 'view_guest' => $this->view_guest, 'engine' => $this->engine, 'view_admin_lock' => $this->view_admin_lock, 'edit_admin_lock' => $this->edit_admin_lock, 'archived' => $this->archived, 'admin' => $this->admin, 'level' => $this->level, 'lft' => $this->lft, 'rgt' => $this->rgt);
  }
  
  protected $childrenInfo;
  
  public function getChildrenInfo($livingOnly = true)
  {
    return aPageTable::getChildrenInfo(array('info' => $this->getInfo(), 'livingOnly' => $livingOnly));
  }

  // TODO: migrate getTreeInfo and getAccordionInfo more fully to the table class level, with options arrays.
  // Then work on killing the old parameters to these methods in favor of an options array at this level too. 
  // I would like to do this for 1.5 but we've addressed the most important use case at this point
  // (users should only see links they have the privileges to visit), so it will have to wait for 1.6
    
  // If $depth is null we get all of the descendants
  // The $livingOnly flag is present for bc only and is ignored, we get what the current user can see
  
  public function getTreeInfo($livingOnly = true, $depth = null)
  {
    // Recursively builds a page tree. If a page has children, the info array for that
    // page will have a 'children' element containing an array of info arrays for its
    // children, etc.
    
    // Efficiently fetches only to the appropriate depth

    // Sometimes trees will have enabled children of disabled parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query

    $infos = $this->getDescendantsInfo(false, $depth);
    $offset = 0;
    $level = 0;
    return $this->getTreeInfoBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $depth, $livingOnly);
  }
  
  protected function getTreeInfoBody($lft, $rgt, $infos, &$offset, $level, $depth, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    if ($depth === 0)
    {
      // Limit depth 
      return $result;
    }
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $children = $this->getTreeInfoBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, isset($depth) ? ($depth - 1) : null, $livingOnly);
      if (count($children))
      {
        $info['children'] = $children;
      }
      if ($livingOnly && isset($info['archived']) && $info['archived'])
      {
        continue;
      }
      else
      {
        $result[] = $info;
      }
    }
    return $result;
  }
  
  
  // Accordion nav 
  // Always starts with the children of the root and comes down to the level of this page's children,
  // listing peers of this page's ancestors at every level. That is:
  
  // Home
  //   One
  //     1a
  //     1b
  //       1bx  <-- the current page
  //         1bxA
  //         ibxB
  //     1c
  //   Two
  
  // You can now specify the root slug, which defaults to the home page.
  
  // Note that children of Two, 1a, and 1c are NOT returned. Only the siblings of
  // the current page's ancestors, the current page and its siblings, and the immediate
  // children of the current page are returned. For a full tree use getTreeInfo().
  
  // The livingOnly flag is present for bc only and is ignored, we get what the current user can see
  
  public function getAccordionInfo($livingOnly = true, $depth = null, $root = '/')
  {
    // As far as I can tell there is no super-elegant, single-query way to do this
    // without fetching a lot of extra pages. So do a peer fetch at each level.
    
    // First build an array of arrays listing the peers at each level

    // If you have enabled children of archived ancestors and you don't
    // want the ancestors to show up, you probably shouldn't be using
    // an accordion contro. in the first place

		// We need all of the ancestors to build an accordion successfully, in particular
		// since we often want a hidden parent to be the root. Give more thought to whether 
		// we can do this just for the root
    $ancestors = aPageTable::getAncestorsInfo(array('info' => $this->getInfo(), 'ignore_permissions' => true));
    // Dump ancestors we don't care about
    $found = false;
    for ($i = 0; ($i < count($ancestors)); $i++)
    {
      if ($ancestors[$i]['slug'] === $root)
      {
				$rootLevel = $ancestors[$i]['level'];
        $ancestors = array_slice($ancestors, $i);
        $found = true;
        break;
      }
    }
    if (!$found)
    {
			// Active page is not a descendant of the root. Just return the children of the root.
			// This makes the accordion more useful when you are not yet under its root
			// I don't have a handy way to do this without cache issues in the table class yet so...
			// This is not a proper info structure but it will work for this job
			$rootInfo = Doctrine::getTable('aPage')->createQuery('p')->where('slug = ?', array($root))->execute(array(), Doctrine::HYDRATE_ARRAY);
			if (!count($rootInfo))
			{
				throw new sfException("Root page of accordion does not exist!");
			}
			$rootInfo = $rootInfo[0];
			return aPageTable::getChildrenInfo(array('info' => $rootInfo));
    }
    $result = array();
    foreach ($ancestors as $ancestor)
    {
      if (($ancestor['level'] > $rootLevel) && $livingOnly && ($ancestor['archived']))
      {
        continue;
      }
      $lineage[] = $ancestor['id'];
      if ($ancestor['level'] == $rootLevel)
      {
        $result[] = array($ancestor);
      }
      else
      {
        // TODO: this is inefficient, come up with a way to call getPeerInfo for an
        // alternate ID without fetching that entire page
        $peers = aPageTable::retrieveBySlug($ancestor['slug'])->getPeerInfo($livingOnly);
        $result[] = $peers;
      }
    }
    // Current page peers level
    $result[] = $this->getPeerInfo($livingOnly);
    $lineage[] = $this->id;
    // Current page children level
    $result[] = $this->getChildrenInfo($livingOnly);
    
    // Now fix it up to be a properly nested array like that
    // returned by getTreeInfo(). On each pass take a reference
    // to the child that will own the children of the next pass
    $accordion = $result[0][0];
    $current = &$accordion;
    for ($i = 0; ($i < (count($result) - 1)); $i++)
    {
      $current['children'] = $result[$i + 1];
      if ($i + 1 < count($lineage))
      {
        // We've already started returning the kids as a flat array so 
        // we need to scan for it unfortunately. This entire method could
        // use more attention to performance
        foreach ($current['children'] as &$child)
        {
          if ($child['id'] == $lineage[$i + 1])
          {
            $current = &$child;
            break;
          }
        }
      }
    }
    
    // Don't return the home page itself, start with the tabs.
    // This is consistent with getTreeInfo() which should simplify implementations.
    // It's easy to add the home page in at a higher level if desired.
    return $accordion['children'];
  }

  // Used by the reorganize feature. Return value is compatible with jstree. 
  // See getTreeInfo for something more appropriate for front end navigation
  
  public function getTreeJSONReady($livingOnly = true)
  {
    // Recursively builds a page tree ready to be JSON-encoded and sent to
    // the jsTree object (yes this is rather specific to jsTree for the model layer,
    // but this would be a reasonable input format for any JS tree implementation).
    
    // Sometimes trees will have enabled children of archived parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query
    $infos = $this->getDescendantsInfo(false);
    $offset = 0;
    $level = 0;
    $tree = array("attributes" => array("id" => "tree-" . $this->id),
      "data" => $this->getTitle(),
      "state" => 'open',
      "children" => $this->getTreeJSONReadyBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $livingOnly)
    );
    if (!count($tree['children']))
    {
      unset($tree['children']);
    }
    else
    {
      $item['state'] = 'open';
    }
  return $tree;
  }

  protected function getTreeJSONReadyBody($lft, $rgt, $infos, &$offset, $level, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $class = ($info['archived'])? 'archived' : 'alive';
      $class.= (!is_null($info['engine']))? ' engine-'.$info['engine'] : '';
      $item = array(
        "attributes" => array("id" => "tree-" . $info['id'], "class" => $class), 
        "data" => $info['title'],
        "children" => $this->getTreeJSONReadyBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, $livingOnly)
      );
      if (!count($item['children']))
      {
        unset($item['children']);
      }
      else
      {
        $item['state'] = ($level < 2) ? "open" : "closed";
      }
      if ($livingOnly && isset($info['archived']) && $info['archived'])
      {
        // Skip it (and therefore its children as well) in the final result
      }
      else
      {
        $result[] = $item;
      }
    }
    return $result;
  }
  
  // Low level access to all info for all descendants. You probably don't want this. For an interface that
  // gives you back a hierarchy see getTreeInfo. 
  // The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
  protected function getDescendantsInfo($livingOnly = true, $depth = null)
  {
    $where = '( p.lft > ' . $this->lft . ' AND p.rgt < ' . $this->rgt . ' )';
    if (isset($depth))
    {
      $where = '(' . $where . ' AND (p.level <= ' . ($this->level + $depth) . '))';
    }
    return $this->getPagesInfo($livingOnly, $where);
  }
  
  // This is the low level query method used to implement the above. You won't call this directly
  // unless you're implementing a new type of query for related pages. 
  // The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
  
  protected function getPagesInfo($livingOnly = true, $where, $admin = false)
  {
    return aPageTable::getPagesInfo(array('culture' => $this->getCulture(), 'where' => $where, 'admin' => $admin));
  }

  // The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
  public function hasChildren($livingOnly = true)
  {
    // not as inefficient as it looks because of the caching feature
    return (count($this->getChildren($livingOnly)) != 0);
  }

  public function getUrl($absolute = true)
  {
    return aTools::urlForPage($this->getSlug(), $absolute);
  }

  public function getAncestors()
  {
    // Home page has no ancestors; save a query on a popular page
    if ($this->level == 0)
    {
      return array();
    }
    if ($this->ancestorsCache !== false)
    {
      return $this->ancestorsCache;
    } 
    aPageTable::treeTitlesOn();
    $this->ancestorsCache = $this->getNode()->getAncestors();
    aPageTable::treeTitlesOff();
    if ($this->ancestorsCache === false)
    {
      // Empty lists are not evil!
      $this->ancestorsCache = array();
    }
    return $this->ancestorsCache;
  }
  public function isEqualTo($page)
  {
    return ($page->getSlug() === $this->getSlug());
  }

  public function begin()
  {
    $conn = Doctrine_Manager::connection();
    $conn->beginTransaction();
  }

  public function end()
  {
    $conn = Doctrine_Manager::connection();
    $conn->commit();
  }

  // SAVE ANY CHANGES to the actual page object FIRST before you call this method.

  // 20090505: you must pass valid HTML text (i.e. pre-escaped entities)
  public function setTitle($title)
  {
    $slot = $this->createSlot('aText');
    $slot->value = $title;
    $slot->save();
    $this->newAreaVersion('title', 'update', 
      array(
        'permid' => 1, 
        'slot' => $slot));
  }

  public function setMetaDescription($description)
  {
  	$slot = $this->createSlot('aText');
  	$slot->value = $description;
  	$slot->save();
  	
  	$this->newAreaVersion('metaDescription', 'update',
  		array(
  			'permid' => 1,
  			'slot' => $slot));
  	
  }


  // SAVE ANY CHANGES to the actual page object FIRST before you call this method.
  
  public function newAreaVersion($name, $action, $params = false)
  {
    // Lock this page while adding a new version to it. This prevents race conditions with the
    // assignment of new permids and ranks (fixes #306)
    aTools::lock('page_' . $this->id);
    
    $diff = '';
    if ($params === false)
    {
      $params = array();
    }
    $this->begin();
    // We use the slots already queried as a basis for the new version,
    // because that makes rollback easy to implement etc. But we
    // MUST fetch the latest copy of the area object to make sure
    // we don't create duplicate versions.

    // When we're adding a new slot to an area we need to make sure it
    // it is first in the hash so it gets ranked first
    if ($action === 'add')
    {
      // New: support for specifying whether the new slot is at top or bottom of the area
      $top = (!isset($params['top'])) || $params['top'];
      $diff = (isset($params['slot']))? "<strong>" . aString::limitCharacters($params['slot']->getSearchText(), 20) . "</strong>" : '';
      $newSlots = $this->getArea($name, $params['slot'], $top);
    }
    else
    {
      $newSlots = $this->getArea($name);
    }
    $area = aAreaTable::retrieveOrCreateByPageIdAndName(
      $this->id,
      $name);
    if (!$area->id)
    {
      // We need an ID established
      $area->save();
    }
    $areaVersion = new aAreaVersion();
    $areaVersion->area_id = $area->id;
    $areaVersion->version = $area->latest_version + 1;
    // Don't crash on an anon edit, such as an edit made by a task
    if (sfContext::hasInstance() && sfContext::getInstance()->getUser()->getGuardUser())
    {
      $areaVersion->author_id = 
        sfContext::getInstance()->getUser()->getGuardUser()->getId();
    }
    if ($action === 'delete')
    {
      if (isset($newSlots[$params['permid']]))
      {
        $diff = '<strike>' . aString::limitCharacters($newSlots[$params['permid']]->getSearchText(), 20) . '</strike>';
        unset($newSlots[$params['permid']]);
      }
    }
    elseif ($action === 'update')
    {
      $oldText = '';
      if (isset($newSlots[$params['permid']]))
      {
        $oldText = $newSlots[$params['permid']]->getSearchText(); 
      }
      $newText = (isset($params['slot']))? $params['slot']->getSearchText() : '';
      $fullDiff = aString::diff($oldText, $newText);
      $diff = '';
      if (!empty($fullDiff['onlyin1']))
      {
        $diff .= '<strike>' . aString::limitCharacters($fullDiff['onlyin1'][0], 20) . '</strike>';
      }
      if (!empty($fullDiff['onlyin2']))
      {
        $diff .= '<strong>' . aString::limitCharacters($fullDiff['onlyin2'][0], 20) . '</strong>';
      }
      $newSlots[$params['permid']] = $params['slot']; 
    }
    elseif ($action === 'variant')
    {
      $newSlot = $newSlots[$params['permid']]->copy();
      if (!$newSlot)
      {
        throw new sfException('Slot does not exist');
      }
      $variants = sfConfig::get('app_a_slot_variants');
      if (!isset($variants[$newSlot->type][$params['variant']]))
      {
        throw new sfException('Variant not defined for this slot type');
      }
      $newSlot->variant = $params['variant'];
      // Must have an id before we can make an AreaVersionSlot referencing it
      $newSlot->save();
      $newSlots[$params['permid']] = $newSlot;
      $diff = $newSlot->variant;
    }
    elseif ($action === 'add')
    {
      // We took care of this in the getArea call
    }
    elseif ($action === 'sort')
    {
      $diff = '[Reordered slots]';
      $newerSlots = array();
      foreach ($params['permids'] as $permid)
      {
        $newerSlots[$permid] = $newSlots[$permid];
      }
      $newSlots = $newerSlots;
    }
    elseif ($action === 'revert')
    {
      // TODO: actually represent the changes carried out by the reversion
      // in the diff. That's rather expensive because many slots in the area
      // may have changed all at once.
      $diff = '[Reverted to older version]';
      # We just want whatever is in the slot cache copied to a new version
    }
    
    $areaVersion->diff = $diff;
    $areaVersion->save();

    $rank = 1;
    foreach ($newSlots as $permid => $slot)
    {
      // After unset, foreach shows keys but has null values
      if (!$slot)
      {
        continue;
      }
      $areaVersionSlot = new aAreaVersionSlot();
      $areaVersionSlot->slot_id = $slot->id;
      $areaVersionSlot->permid = $permid;
      $areaVersionSlot->area_version_id = $areaVersion->id;
      $areaVersionSlot->rank = $rank++;
      $areaVersionSlot->save();
    }
    $area->latest_version++;
    $area->save();
    $this->requestSearchUpdate();
    $this->end();
    aTools::unlock();
  }
    
  public function requestSearchUpdate($allcultures = false)
  {
  	// we want to build an array so we can map the Lucene update across all elements
  	$aPages = array($this);
  	if ($allcultures)
  	{
  		$aPages = array();
  		
  		$cultures = array();

			$page = Doctrine::getTable('aPage')
				->createQuery('p')
				->where('p.id = ?', $this->id)
				->leftJoin('p.Areas a')
				->fetchOne(array(), Doctrine::HYDRATE_ARRAY);
 
			foreach ($page['Areas'] as $area)
			{
				$cultures[$area['culture']] = true; 
			}

			$cultures = array_keys($cultures);

			foreach ($cultures as $culture)
			{
				$aPages[] = aPageTable::retrieveByIdWithSlots($this->id, $culture);
			}
  	}
  	
  	// save a variable for the update function
    if (sfConfig::get('app_a_defer_search_updates', false))
    {
  		// Deferred updates are sometimes nice for performance...
  		foreach ($aPages as $page)
    	{
  		  aLuceneUpdateTable::requestUpdate($page);
  		}
    }
    else
    {
  		// ... But the average developer hates cron.
   		
    	// Without this the changes we just made aren't visible to getSearchText,
  		// we need to trigger a thorough recaching
  	
  		foreach ($aPages as $page)
  		{
		  	aPageTable::retrieveByIdWithSlots($page->id);
		    $page->updateLuceneIndex();   
  		}
    }
  }
  
  public function clearSlotCache()
  {
    $this->slotCache = false;
  }

  public function getAccessesById($privilege)
  {
    $candidateGroup = sfConfig::get('app_a_' . $privilege . '_candidate_group', false);
    $sufficientGroup = sfConfig::get('app_a_' . $privilege . '_sufficient_group', false);
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $withClauses = array();
    $withParameters = array();
    if ($candidateGroup)
    {
      $candidateGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($candidateGroup);
      if (!$candidateGroup)
      {
        throw new Exception("Candidate group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $candidateGroup->id;
    }
    if ($sufficientGroup)
    {
      $sufficientGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($sufficientGroup);
      if (!$sufficientGroup)
      {
        throw new Exception("Sufficient group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $sufficientGroup->id;
    }
    if (count($withClauses))
    {
      $query->innerJoin("u.Groups g with " . implode(" OR ", $withClauses),
        $withParameters);
    } 
    $query->orderBy("u.username asc");
    $allResults = $query->execute();
    $all = array();
    $sufficient = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->username;
      if ($sufficientGroup && ($actor->hasGroup($sufficientGroup->getName())))
      {
        $sufficient[] = $actor->id;
      }
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("u.Accesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("u.username asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $user)
    {
      foreach ($user->Accesses as $access)
      {
        if (!isset($found[$user->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $user->id;
            $found[$user->id] = true;
          }
          else
          {
            $selected[] = $user->id;
            $found[$user->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited, $sufficient);
  }
  public function setAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    // Make sure we select() only a.* so that we don't wind up
    // reloading the page object and causing problems in updateObject().
    $query->select('a.*')
      ->from('aAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new aAccess();
      $access->user_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }
 
  public function getGroupAccessesById($privilege)
  {
    $query = Doctrine_Query::create();
    $query->from("sfGuardGroup g");
    // Don't give this permission to the admin or guest groups. That way they don't become
    // candidates to receive page editing permissions (admin doesn't need them and guest
    // should never have them). Don't give it to editor either, since that defeats the purpose
    // of having a group of people who can be granted permissions individually
    $query->innerJoin('g.Permissions p WITH p.name = ?', sfConfig::get('app_a_group_editor_permission', 'editor'));
    $query->orderBy("g.name asc");
    $allResults = $query->execute();
    $all = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->name;
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardGroup g");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("g.GroupAccesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("g.name asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $group)
    {
      foreach ($group->Accesses as $access)
      {
        if (!isset($found[$group->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $group->id;
            $found[$group->id] = true;
          }
          else
          {
            $selected[] = $group->id;
            $found[$group->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited);
  }
  
  public function setGroupAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    // Make sure we select() only a.* so that we don't wind up
    // reloading the page object and causing problems in updateObject().
    $query->select('a.*')
      ->from('aGroupAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new aGroupAccess();
      $access->group_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }
  
  // The parent object comes back with a populated title slot.
  // The other slots are NOT populated for performance reasons
  // (is there a scenario where this would be a problem?)
  public function getParent($with = false)
  {
    if ($this->parentCache === false)
    {
      aPageTable::treeTitlesOn();
      $this->parentCache = $this->getNode()->getParent();
      aPageTable::treeTitlesOff();
    }
    return $this->parentCache;
  }

  public function delete(Doctrine_Connection $conn = null)
  {
    // TODO: must delete outstanding indexing requests here
    return aZendSearch::deleteFromDoctrineAndLucene($this, null, $conn);
  }

  public function doctrineDelete(Doctrine_Connection $conn)
  {
    return parent::delete($conn);
  }

  public function save(Doctrine_Connection $conn = null)
  {
    $result = parent::save($conn);
    $this->requestSearchUpdate(true);
    return $result;
  }

  public function doctrineSave(Doctrine_Connection $conn)
  {
    return parent::save($conn);
  }

  public function updateLuceneIndex()
  {
    if ($this->getAdmin())
    {
      // Never index admin pages, that goes against the spirit of 
      // keeping them completely out of navigation, they are not
      // a place for content in the normal sense, they are engines
      // for administrative purposes
      return;
    }
    $title = $this->getTitle();
    $engine = $this->getEngine();
    $summary = $this->getSearchSummary();
    $text = $this->getSearchText();
    $tags = implode(',', $this->getTags());
    $categories = array();
    $categoryObjects = $this->getCategories();
    foreach ($categoryObjects as $category)
    {
      $categories[] = $category->getName();
    }
    $categories = implode(',', $categories);
    $metaDescription = $this->getMetaDescription();
    $slug = $this->getSlug();
    $info = $this->getInfo();
    // Already separate fields, so don't store them twice.
    unset($info['title'], $info['engine']);
    $tags = $this->getTags();
    $args = array('object' => $this,
      'indexed' => array('text' => $text, 'slug' => $slug, 'title' => $title, 'tags' => implode(', ', $tags), 'categories' => $categories, 'metadescription' => $metaDescription, 'engine' => $engine),
      'culture' => $this->getCulture(),
      // 1.5: always store fields under a name different from that used to index them.
      // Otherwise the storage overrides the indexing
      'stored' => array(
        'title_stored' => $title,
        'summary_stored' => $summary,
        'slug_stored' => $slug,
        // Nulls don't store well in Lucene
        'engine_stored' => strlen($engine) ? $engine : '',
        'info_stored' => serialize($info)),
      'boosts' => array('tags' => 2.0, 'metadescription' => 1.2, 'title' => 3.0),
      'keywords' => array(
        // We index the publication timestamp as a string consisting solely of digits. That allows
        // us to use Zend Lucene's TO construct to look at items published from now until eternity
        'published_at' => preg_replace('/[^\d]/', '', $this->published_at)
      ));
    if (strlen($engine))
    {
      $helperClass = $engine . 'SearchHelper';
      if (class_exists($helperClass))
      {
        $searchHelper = new $helperClass;
        $args = $searchHelper->filterUpdateLuceneIndex($args);
      }
    }
    aZendSearch::updateLuceneIndex($args);
  }

  public function getSearchSummary()
  {
    return aString::limitWords($this->getSearchText(false), sfConfig::get('app_a_search_summary_wordcount', 50), "...");
  }

  public function getSearchText($withTitle = true)
  {
    $text = "";
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture]))
    {
      foreach ($this->slotCache[$this->culture] as $name => $area)
      {
        if (!$withTitle)
        {
          if ($name === 'title')
          {
            continue;
          }
        }
        foreach ($area as $permid => $slot)
        {
          $text .= $slot->getSearchText() . "\n";
        }
      }
    }
    return $text;
  }

  // Pages can contain slots for all cultures, but this returns the
  // culture associated with the slots that were retrieved with
  // the page in this particular case.
  public function getCulture()
  {
    return $this->culture;
  }

  // You don't call this ordinarily. It's part of the implementation of
  // fetching a page along with slots for a particualr culture.
  public function setCulture($culture)
  {
    $this->culture = $culture;
  }
  
  public function getPeersAsOptionsArray()
  {
    $peers = array();
    $parent = $this->getParent();
    if (!$parent)
    {
      return $peers;
    }
    $children = $parent->getChildren();
    foreach ($children as $child)
    {
      if ($child->id === $this->id)
      {
        continue;
      }
      $peers[$child->id] = $child->getTitle();
    }
    return $peers;
  }
  
  public function getCategoriesInfo($class = null)
  {
    // Returns information about the categories this page is related to, or all pages if it is not
    // locked down to any particular categories. Limits results to one class of categorizable type if
    // desired. In that case you receive only the results for that class rather than an array of
    // results for multiple classes
    
    // It's simplest to get the info about all categories and types, and then cut down 
    // (TODO: we could have the event require the getters to filter this in advance,
    // but I'm not sure it's worth the pain and potential for error)

    $event = new sfEvent(null, 'a.get_count_by_category');
    sfContext::getInstance()->getEventDispatcher()->filter($event, array());
    $counts = $event->getReturnValue();

    $fcounts = array();
    
    $categories = $this->getCategories();
    if (!count($categories))
    {
      $categories = Doctrine::getTable('aCategory')->findAll();
    }
    $ids = aArray::listToHashById($categories);
    foreach ($counts as $cclass => $countsInfo)
    {
      $fcountsInfo = $countsInfo;
      foreach ($countsInfo['counts'] as $id => $info)
      {
        if (!isset($ids[$id]))
        {
          unset($fcountsInfo['counts'][$id]);
        }
      }
      $fcounts[$cclass] = $fcountsInfo;
    }
    if (!is_null($class))
    {
      if (isset($fcounts[$class]))
      {
        return $fcounts[$class];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return $fcounts;
    }
  }
    
  public function updateLastSlugComponent($title)
  {
    if ($this->slug === '/')
    {
      // We never update the home page slug
      return;
    }
    if ($this->getCulture() !== sfConfig::get('sf_default_culture'))
    {
      // Retitling a page in a culture other than the default does not
      // change the page slug
      return;
    }
    $component = aTools::slugify($title, false);
    $path = $this->slug;
    if (function_exists('mb_strrpos'))
    {
      $slash = mb_strrpos($path, '/');
      $newPath = mb_substr($path, 0, $slash + 1) . $component;
    }
    else
    {
      $slash = strrpos($path, '/');
      $newPath = substr($path, 0, $slash + 1) . $component;
    }
    if ($path === $newPath)
    {
      return;
    }
    $this->slug = $newPath;
    $this->save();
    Doctrine::getTable('aRedirect')->update($path, $this);
    $children = $this->getChildren();
    foreach ($children as $child)
    {
      $child->updateParentSlug($path, $newPath);
    }
  }
  
  // Update your slug based on your current parent's slug - no discussion or debate permitted.
  // Reorganize uses this. CAN be called when the parent is root, so be careful not to 
  // set a double slash as a prefix
  
  public function forceSlugFromParent()
  {
    $pslug = $this->getNode()->getParent()->slug;
    if ($pslug === '/')
    {
      $pslug = '';
    }
    if (function_exists('mb_substr'))
    {
      $slash = mb_strrpos($this->slug, '/');
      $newSlug = $pslug . mb_substr($this->slug, $slash);
    }
    else
    {
      $slash = strrpos($this->slug, '/');
      $newSlug = $pslug . substr($this->slug, $slash);      
    }
    if ($this->slug !== $newSlug)
    {
      Doctrine::getTable('aRedirect')->update($this->slug, $this);
      $this->slug = $newSlug;
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->forceSlugFromParent();
      }
    }
  }
  
  // The parent's slug has changed (it is still the same parent). This is just an FYI - pges whose slugs
  // already diverge from the parent don't have to update their slugs too. Should never be called
  // when the parent is root
  
  public function updateParentSlug($old, $new)
  {
    if ($old === '/')
    {
      throw new sfException("You can't change the slug of the root page, why are we here?");
    }
    // Make sure this page's slug is actually prefixed by its parent's slug followed
    // by a /. If not, it has already been customized and should not get uncustomized
    // just because somebody edited the title or slug of the parent
    $slug = $this->slug;
    $old .= '/';
    if (function_exists('mb_substr'))
    {
      $stem = mb_substr($slug, 0, mb_strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = mb_strrpos($slug, '/');
      $newSlug = $new . mb_substr($slug, $slash);
    }
    else
    {
      $stem = substr($slug, 0, strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = strrpos($slug, '/');
      $newSlug = $new . substr($slug, $slash);
    }
    
    if ($slug !== $newSlug)
    {
      $this->slug = $newSlug;
      Doctrine::getTable('aRedirect')->update($slug, $this);
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->updateParentSlug($slug, $newSlug);
      }
    }
  }  
  
  // We may need this before we're done
  // protected function str_replace($old, $new, $content)
  // {
  //   if (function_exists('mb_strpos'))
  //   {
  //     $at = 0;
  //     while (($at = mb_strpos($content, $old, $at)) !== false)
  //     {
  //       $content = mb_substr($content, 0, $at) . $new . mb_substr($content, $at + mb_strlen($old));
  //       $at = $at + strlen($old);
  //     }
  //   }
  // }
}
